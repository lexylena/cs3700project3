#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
from random import randint
from collections import OrderedDict
import time

alpha = 0.875
MTU = 1500
MSS = 1500 - 2*sys.getsizeof(int()) - 3*sys.getsizeof(bool()) - 20   # MTU - header fields

RTT = 1  # TODO: set initial value during connection setup
RTO = 1     # initially 3 seconds, recalculated after first RTT

SEQUENCE = randint(0, 10)
syn_num = SEQUENCE
ACK = None # last received ACK number

cwnd = 1                    # congestion window
adv_wnd = 50                # receiver advertised window (TODO: set in connection setup)
ssthresh = adv_wnd          # threshold size (used to update cwnd)
# eff_wnd = min(cwnd, adv_wnd)
eff_wnd = 0

# OrderedDict[(unACKed packet's SEQ number, [time sent, data])] sorted by chronological sent times
# used for RTT sampling, RTO, and receiving out-of-order ACKs
#   - each time packet sent, add (seq#, [time sent, data])
#   - when ACK received, record time received, calc_rto(unacked_packets[ack#], time received), remove ack# from dict
unacked_packets = OrderedDict([])
dup_acks_count = 0 # retransmit at 3
synced = True # has connection been setup successfully?

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setblocking(0)
sock.settimeout(30)


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

'''
Sender Packet Format:
    - seq_num
    - ack
    - syn
    - fin
    - data
'''

# recalculate RTO given the times a packet was sent and when its ACK was received
# unacked_data is [datetime sent_time, string data, bool retransmitted]
# acked_time is a datetime
def calc_rto(unacked_data, acked_time):
    global RTT, RTO
    if unacked_data[2]: # if the sample is a retransmitted packet
        return
    else:
        diff = acked_time - unacked_data[0]
        sample =diff.seconds + diff.microseconds/float(1000000)
        # log("[RTT sample] " + str(sample))
        RTT = alpha * RTT + (1 - alpha) * sample
        # log("[RTT] = " + str(RTT))
        RTO = 2 * RTT


# send syn packet and setup connection (handshake)
def setup_connection():
    global SEQUENCE, unacked_packets, RTO
    # Send first syn packet
    msg = json.dumps({"syn": True, "seq_num": SEQUENCE, "data": "", "fin": False, "ack": False})
    log("[SYN] " + str(SEQUENCE))
    unacked_packets[SEQUENCE] = [datetime.datetime.now(), "", False]
    SEQUENCE += 1
    sock.sendto(msg, dest)


# retransmit the given packet
def retransmit_after_timeout(unacked):
    global cwnd, eff_wnd, ssthresh, dup_acks_count, unacked_packets, SEQUENCE
    # if unacked[1][1] == "":
    #     msg = json.dumps({"syn": True, "seq_num": SEQUENCE-1, "data": "", "fin": False, "ack": False})
    #     log("[retransmission] SYN " + str(SEQUENCE-1))
    #     unacked_packets[SEQUENCE] = [datetime.datetime.now(), ""]
    #     sock.sendto(msg, dest)
    # else:
    # log("UPDATING SSTHRESH RETRANSMIT AFTER T/O")
    ssthresh = cwnd / 2
    cwnd = 1
    # eff_wnd = min(cwnd, adv_wnd)
    # log("RESETTING DUP_ACKS_COUNT retransmit after timeout")
    dup_acks_count = 0
    log("[retransmission (timeout)] " + str(unacked[0]))
    msg = json.dumps({"seq_num": unacked[0], "data": unacked[1][1],
                      "fin": False, "syn": False, "ack": False})

    # SEQUENCE = unacked[0] + len(unacked[1][1]) # reset SEQUENCE to after retransmitted packet
    unacked_packets[unacked[0]][2] = True # set retransmitted to True

    # eff_wnd -= 1
    # log("[eff_wnd retransmit_After_timeout] " + str(eff_wnd))
    if sock.sendto(msg, dest) < len(msg):
        log("[error] unable to fully send packet")



# check timeouts for unacked packets
# if timeout, retransmit_after_timeout and return True
# if no timeout, return False
def check_timeout():
    log("CHECKING TIMEOUT")
    global RTO, unacked_packets, SEQUENCE
    items = unacked_packets.items()
    unacked = None
    for ii in range(len(items)):
        unacked = items[ii]
        diff = datetime.datetime.now() - unacked[1][0]
        if diff.seconds + diff.microseconds / 1000000 >= RTO:
            # timed out waiting for ACK with ack_num given
            log("[timeout] ACK " + str(unacked[0] + len(unacked[1][1])))
            retransmit_after_timeout(unacked)

    # if unacked is None: # no timeouts
    #     return False
    # else:
    #     retransmit_after_timeout(unacked)
    #     return True


def send_next_packet():
    global SEQUENCE, unacked_packets, eff_wnd
    # log("[eff_wnd] " + str(eff_wnd))

    # if SEQUENCE%(MSS*2) == syn_num and SEQUENCE != syn_num:
    #     log("seq mod for timeout = " + str(SEQUENCE%(MSS*3)))
    check_timeout()
    # if (eff_wnd >= 1):
    while (min(cwnd, adv_wnd) - eff_wnd > 0):
        retransmit = unacked_packets.get(SEQUENCE, None)
        if retransmit: # if SEQUENCE already in unacked_packets, it's a retransmission
            data = retransmit[1]
            unacked_packets[SEQUENCE][0] = datetime.datetime.now()
            unacked_packets[SEQUENCE][2] = True
        else:
            data = sys.stdin.read(MSS)

        if (len(data) > 0):
            msg = json.dumps({"seq_num": SEQUENCE, "data": data, "fin": False,
                              "syn": False, "ack": False})
            if not retransmit:
                unacked_packets[SEQUENCE] = [datetime.datetime.now(), data, False]

            # log("Sequence sent" + str(SEQUENCE))
            SEQUENCE += len(data)

            # decrement effective window size
            # eff_wnd -= 1
            eff_wnd+=1
            # log("[eff_wnd send next packet after sending] " + str(eff_wnd))

            if sock.sendto(msg, dest) < len(msg):
                log("[error] unable to fully send packet")
            else:
                log("[send data] " + str(SEQUENCE - len(data)) + " (" + str(len(data)) + ")")
            # return True
        else:
            return False
    # else:
    return True


# def fast_retransmit(seq_num):
#     global cwnd, eff_wnd, ssthresh, unacked_packets, dup_acks_count, SEQUENCE
#     # log("UPDATING SSTHRESH FAST RETRANSMIT")
#
#     # fast recovery
#     cwnd = ssthresh / 2
#     # eff_wnd = min(cwnd, adv_wnd)
#     # log("RESETTING DUP_ACKS_COUNT fast retransmit")
#
#     dup_acks_count = 0
#
#     # unacked_packets contains packets mapped to their SEQ number
#     # if receiver sends duplicate ACKs for an ack_num, then need to resend packet with SEQUENCE=ack_num
#     # if last packet and len < MSS, get the first (and only) unacked packet
#     packet = unacked_packets[seq_num]
#
#     msg = json.dumps({"seq_num": seq_num, "data": packet[1], "fin": False,
#                       "syn": False, "ack": False})
#     log("[FAST RETRANSMIT] DATA packet " + str(seq_num))
#     # eff_wnd -= 1
#     eff_wnd+=1
#     # log("[eff_wnd fast_retransmit] " + str(eff_wnd))
#
#     if sock.sendto(msg, dest) < len(msg):
#         log("[error] unable to fully send packet")
#
#     SEQUENCE = seq_num + len(packet[1])        # reset SEQUENCE to last missing packet
#     unacked_packets[seq_num][2] = True         # set retransmitted to True (exclude from RTT sampling)


def teardown_connection(attempts):
    global unacked_packets, eff_wnd, SEQUENCE, RTO
    log("[teardown]")
    # if len(unacked_packets.items()) > 0:
    #     log("[fin error] unacked_packets len > 0")
    #     log("unacked_packets = " + str(unacked_packets))
    #     sys.exit(0)
    # else:
    if attempts < 3:
        log("[teardown] SEQ " + str(SEQUENCE))
        sock.sendto(json.dumps({"fin": True, "data": "", "seq_num": SEQUENCE, "ack": False, "syn": False}), dest)
        ready = select.select([sock], [], [], RTO)
        if ready[0]:
            result = ready[0][0].recvfrom(MTU)
            (data, addr) = result
            try:
                decoded = json.loads(data)
                log("[teardown sender received] " + str(decoded))
                if decoded['fin'] and decoded['ack'] == SEQUENCE+1:
                    log("[fin/ack] " + str(decoded['ack']))
                    sys.exit(0)
                else:
                    log("[fin/ack error] " + str(decoded['ack']))
                    sys.exit(0)
            except():
                log("[recv corrupt fin packet]")
                teardown_connection(attempts+1)
        else:
            teardown_connection(attempts+1)
    else:
        log("sender exiting")
        sys.exit(1)




############################### MAIN #########################################
# setup_connection()
send_next_packet()
while True:
    # log("ABOUT TO SLEEP")
    # log("SELECT TIMEOUT = " + str(RTO))

    ready = select.select([sock], [], [], RTO)
    if ready[0]:
        result = ready[0][0].recvfrom(MTU)
        ack_time = datetime.datetime.now()
        (data, addr) = result
        # log("data:" + str(data))
        try:
            decoded = json.loads(data)

            if decoded['syn'] and decoded['ack'] == SEQUENCE:
                syn = SEQUENCE - 1 # sequence # of syn packet
                log("[recv SYN/ACK] " + str(SEQUENCE) + " : Connection establishing")
                synced = True
                calc_rto(unacked_packets[syn], ack_time)

                # sample = ack_time - unacked_packets[syn][0]
                # syn_rtt = sample.seconds + sample.microseconds/float(1000000)
                # # RTT = syn_rtt.seconds + syn_rtt.microseconds/float(1000000)
                # RTT = alpha * syn_rtt + (1 - alpha) * syn_rtt
                # RTO = 2 * RTT
                del unacked_packets[syn]
                # log("sending first data packet")
                send_next_packet()

            else:
                # If there is an ack, process that ACK (duplicate? retransmit? send next packet?)
                ack_num = decoded['ack']
                seq_num = ack_num - MSS


                # get the [sent_time, data, retransmitted] for the packet the ack_num is for
                unacked_data = unacked_packets.get(seq_num, None)

                # check if last packet only one unacked and length of data < MSS
                all_unacked = unacked_packets.items()
                # log("unacked_data is None? " + str(unacked_data))
                if not unacked_data and len(all_unacked) == 1:
                    last_packet_seq = ack_num - len(all_unacked[0][1][1])
                    if all_unacked[0][0] == last_packet_seq:
                        # log("CHECKING IF ACK_NUM - LEN LAST PACKET = LAST PACKET SEQ (" + str(ack_num) + " - " +
                        #     str(len(all_unacked[0][1][1])) + " =? " + str(last_packet_seq))
                        seq_num = last_packet_seq
                        unacked_data = unacked_packets[seq_num]

                # log("\n[RECV ACK] " + str(seq_num) + "\n\n")





                if unacked_data is not None: # not a duplicate ACK
                    log("[recv ack] " + str(ack_num))
		    
                    # update cwnd and RTO if not retransmitted packet ACK
                    # (retransmitted packets should have value set to 0)

                    # if unacked_data[0] is not 0:
                    calc_rto(unacked_data, ack_time)
                    del unacked_packets[seq_num] # remove acked packet from unacked_packets

                    # log("[cwnd, ssthresh, eff_wnd] " + str(cwnd) + "  " + str(ssthresh)+ "  " + str(eff_wnd-1))

                    if cwnd < ssthresh: # slow start
                        # log("SLOW START")
                        cwnd += 1
                    else: # congestion avoidance
                        # log("CONGESTION AVOIDANCE")
                        cwnd += 1 / cwnd

                    eff_wnd-=1
                    # log("[wnd] " + str(min(cwnd, adv_wnd) - eff_wnd))
                    # if eff_wnd < min(cwnd, adv_wnd):
                    #     eff_wnd += 1
                    #     log("[eff_wnd add ACK] " + str(eff_wnd))

                    # Try to send next packet; break if no more data
                    if (not send_next_packet()) and len(unacked_packets.items()) == 0:
                        break
                        # log("[FIN] no more data")
                        # break

                # packet matching ACK not in unacked_packets ==> duplicate ACK so ignore
                else:
                    check_timeout()
                    # dup_acks_count += 1
                    # log("dupes " + str(dup_acks_count))
                    # eff_wnd-=1
                    # # if eff_wnd < min(cwnd, adv_wnd):
                    # #     eff_wnd += 1
                    #     # log("[eff_wnd add dupack] " + str(eff_wnd))
                    #
                    # if dup_acks_count < 3:
                    #     check_timeout()
                    # else:
                    #     log("[dup ack] " + str(ack_num))
                    #     fast_retransmit(seq_num)
                    #     #  dup_acks_count = 0


            # replace with thread for monitoring timeouts?
            #check_timeout()
        except ('''ValueError, KeyError, TypeError'''):
            log("[recv corrupt packet]")
            eff_wnd-=1
            # if eff_wnd < min(cwnd, adv_wnd):
            #     eff_wnd += 1
                # log("[eff_wnd add corrupt ack] " + str(eff_wnd))

    else:
        log("[timeout]")
        if not synced:
            SEQUENCE -= 1
            log("[retransmission] SYN")
            setup_connection()
        else:
            items = unacked_packets.items()
            if len(items) > 0:
                # log("[retransmission after timeout] " + str(items[0]))
                retransmit_after_timeout(items[0])
            #else:
            #   log("no more unacked_packets: " + str(len(items)))
             #   break

teardown_connection(0)
