#!/usr/bin/python -u
#
# CS3700, Spring 2015
# Project 2 Starter Code
#

import sys
import socket
import time
import datetime
import select
import json
from random import randint
from collections import OrderedDict
import time

alpha = 0.875
MTU = 1500
MSS = 1000 #1500 - 2*sys.getsizeof(int()) - 3*sys.getsizeof(bool())   # MTU - header fields TODO uncomment

RTT = 1  # TODO: set initial value during connection setup
RTO = 3     # initially 3 seconds, recalculated after first RTT

SEQUENCE = randint(0, 10)
ACK = None # receiver's corresponding sequence number set during connection setup

cwnd = 1                    # congestion window
adv_wnd = 4                 # receiver advertised window (TODO: set in connection setup)
ssthresh = adv_wnd          # threshold size (used to update cwnd)
wnd = min(cwnd, adv_wnd)
eff_wnd = wnd # TODO: implement eff_wnd use

# OrderedDict[(unACKed packet's SEQ number, [time sent, data])] sorted by chronological sent times
# used for RTT sampling, RTO, and receiving out-of-order ACKs
#   - each time packet sent, add (seq#, [time sent, data])
#   - when ACK received, record time received, calc_rto(unacked_packets[ack#], time received), remove ack# from dict
unacked_packets = OrderedDict([])
dup_acks_count = 0 # retransmit at 2 (meaning 3 of the same ACKs were received)

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setblocking(0)
sock.settimeout(30)


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

'''
Sender Packet Format:
    - seq_num
    - ack
    - syn
    - fin
    - data
'''

# recalculate RTO given the times a packet was sent and when its ACK was received
# sent and acked are datetime objects
def calc_rto(sent, acked):
    global RTT, RTO
    diff = acked - sent
    # log("calc_rto diff = " + str(diff))
    sample =diff.seconds + diff.microseconds/float(1000000)
    # log("calc_rto sample = " + str(sample))
    RTT = alpha * RTT + (1 - alpha) * sample
    # log("calc_rto rtt = " + str(RTT))
    RTO = 2 * RTT

# TODO: implement
def retransmit_after_timeout():
    return 0

#TODO: change implementation to call retransmit_after_timeout
# check timeouts for unacked packets
# resend packet if timed out and return true
# if no timeouts, return false
def check_timeout():
    global RTO, cwnd, ssthresh, dup_acks_count, unacked_packets, SEQUENCE
    # first entry in unacked_packets was sent first, so its timeout will occur first
    unacked = unacked_packets.items()[0]
    diff = datetime.datetime.now() - unacked[1][0]
    # log("check_timeout")
    # log("diff = " +  str(diff))
    # log("RTO = " + str(RTO))
    if diff.seconds + diff.microseconds/1000000 >= RTO:
        log("[timeout] ACK " + str(unacked[0])) # timed out waiting for ack from receiver
        ssthresh = cwnd / 2
        cwnd = 1
        dup_acks_count = 0
        msg = json.dumps({"seq_num": (unacked[0] - len(unacked[1][1])) ,
                          "data": unacked[1][1], "fin": False,
                          "syn": False, "ack": False})
        log("unacked items " + str(unacked_packets.items()))
        SEQUENCE = unacked[0]
        log("About to send " + str(msg))
        if sock.sendto(msg, dest) < len(msg):
            log("[error] unable to fully send packet")
        return True

    else:
        return False

def send_next_packet():
    global SEQUENCE, unacked_packets, eff_wnd

    if (eff_wnd >= 1):
        retransmit = unacked_packets.get(SEQUENCE, None)
        if retransmit:
            data = retransmit[1]
            #log("unackedpackets[seq][0]" + str(unacked_packets[SEQUENCE][0]))
            unacked_packets[SEQUENCE][0] = 0
        else:
            data = sys.stdin.read(MSS)

        if (len(data) > 0):
            msg = json.dumps({"seq_num": SEQUENCE, "data": data, "fin": False,
                              "syn": False, "ack": False})
            log("Sequence sent" + str(SEQUENCE))
            SEQUENCE += len(data)
            unacked_packets[SEQUENCE] = [datetime.datetime.now(), data]

            if sock.sendto(msg, dest) < len(msg):
                log("[error] unable to fully send packet")
            else:
                log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
            return True
        else:
            return False
    else:
        return True


def fast_retransmit(ack_num):
    global cwnd, ssthresh, unacked_packets, dup_acks_count, SEQUENCE
    log("uackedPackets " + str(unacked_packets) + " ack_num " + str(ack_num))
    packet = unacked_packets[ack_num] #TODO: This throws a keyerror off by 1000 ie ack_num does not include the length in the unacked_packets dict, but the number passed to the func does
    msg = json.dumps({"seq_num": ack_num, "data": packet[1], "fin": False,
                      "syn": False, "ack": False})
    log("[retransmission] packet " + str(ack_num))
    if sock.sendto(msg, dest) < len(msg):
        log("[error] unable to fully send packet")

    SEQUENCE = ack_num + len(packet[1])     # reset SEQUENCE to last missing packet
    unacked_packets[ack_num][0] = 0         # set packet's sent time to 0 (exclude from RTT sampling)

    # fast recovery
    cwnd = ssthresh / 2
    dup_acks_count = 0


# Send first packet
msg = json.dumps({"syn": True, "seq_num": SEQUENCE, "data": "", "fin": False, "ack": False})
log("About to send Syn " + str(SEQUENCE))
SEQUENCE +=1
unacked_packets[SEQUENCE] = [datetime.datetime.now(), ""]
sock.sendto(msg, dest)
#ready = select.select([sock], [], [], RTO)
# Now read in data, send packets
while True:
# <<<<<<< HEAD
# =======
#     time.sleep(RTT)
#     check_timeout()
# >>>>>>> c55fd4fdf3395ee88b345c65a25869f7e404e004
    log("ABOUT TO SLEEP")
    ready = select.select([sock], [], [], RTO)
    if ready[0]:
        # result = sock.recvfrom(MTU)
        result = ready[0][0].recvfrom(MTU)
        ack_time = datetime.datetime.now()
        (data, addr) = result
	log("data:" + str(data))
        try:
            decoded = json.loads(data)

            if decoded['syn']:
                ack_num = decoded['ack']
                log("Connection establishing")

                log("unackepackets " + str(unacked_packets.items()))
                #TODO: This occasionally throws key error
		log("syn ack:" + str(decoded['ack']))
		log("SEQUENCE: " + str(SEQUENCE))
                if decoded['ack'] == SEQUENCE:
                    calc_rto(unacked_packets[decoded['ack']][0], ack_time)
		    del unacked_packets[ack_num]
                    send_next_packet()

            else:
                # If there is an ack, process that ACK (duplicate? retransmit? send next packet?)
                ack_num = decoded['ack']
                sent_time = unacked_packets.get(ack_num, None)

                # TODO: fix where cwnd adjustment is? should adjust whenever any ACK is received? or just new ACKs?
                if sent_time is not None: # not a duplicate ACK
                    log("[recv ack] " + str(ack_num))

                    # update cwnd and RTO if not retransmitted packet ACK
                    # (retransmitted packets should have value set to 0)
                    if sent_time is not 0:
                        calc_rto(unacked_packets[ack_num][0], ack_time)
                        del unacked_packets[ack_num] # remove acked packet from unacked_packets

                        if cwnd < ssthresh: # slow start
                            cwnd += 1
                        else: # congestion avoidance
                            cwnd += 1 / cwnd


                    # Try to send next packet; break if no more data
                    if (not send_next_packet()):
			log("no more data")
                        break

                # packet matching ACK not in unacked_packets ==> duplicate ACK
                else:
                    dup_acks_count += 1
# <<<<<<< HEAD
#                     if dup_acks_count < 2:
#                         check_timeout()
#                     else: # received 3 duplicate ACKs
#                         log("[dup ack]" + ack_num)
#                         fast_retransmit(ack_num)
# =======
                    log("dupes " + str(dup_acks_count))
                    if dup_acks_count < 3:
                        check_timeout()
                    else:
                        log("[dup ack] " + str(ack_num))
                        fast_retransmit(ack_num) #TODO:This is a prob
                        #  dup_acks_count = 0


            # replace with thread for monitoring timeouts?
            #check_timeout()
        except ('''ValueError, KeyError, TypeError'''):
            log("[recv corrupt packet]")
    else:
        # TODO: implement
        retransmit_after_timeout()

#TODO: implement connection tear down
sock.sendto(json.dumps({"fin": True, "data": "", "seq_num": SEQUENCE, "ack": False, "syn": False}), dest)
sys.exit(0)
