#!/usr/bin/python -u

import sys
import socket
import time
import datetime
import select
import json
from random import randint
from collections import OrderedDict
import time

alpha = 0.875
MTU = 1500
MSS = 1500 - 2*sys.getsizeof(int()) - 20   # MTU - header fields

RTT = 1
RTO = 1

SEQUENCE = randint(0, 2^32 - 1)
syn_num = SEQUENCE

cwnd = 1                    # congestion window
adv_wnd = 20                # receiver advertised window (TODO: set in connection setup)
ssthresh = adv_wnd          # threshold size (used to update cwnd)
eff_wnd = 0                 # number of packets currently out

# OrderedDict[(unACKed packet's SEQ number, [datetime sent, string data, bool retransmitted])] sorted by chronological sent times
# used for RTT sampling, RTO, and receiving out-of-order ACKs
#   - each time packet sent, add (seq#, [sent, data, retransmitted])
#   - when ACK received, record time received, calc_rto(unacked_packets[ack#], time received), remove ack# from dict
unacked_packets = OrderedDict([])
synced = True # has connection been setup successfully

# Bind to localhost and an ephemeral port
IP_PORT = sys.argv[1]
UDP_IP = IP_PORT[0:IP_PORT.find(":")]
UDP_PORT = int(IP_PORT[IP_PORT.find(":")+1:])
dest = (UDP_IP, UDP_PORT)

# Set up the socket
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
sock.setblocking(0)
sock.settimeout(30)


def log(string):
    sys.stderr.write(datetime.datetime.now().strftime("%H:%M:%S.%f") + " " + string + "\n")

'''
Sender Packet Format:
    - seq_num
    - flags
        - 1 = syn, 2 = fin, 4 = ack (add to combine flags, ex: 5 = syn/ack)
    - data
'''

# recalculate RTO given the times a packet was sent and when its ACK was received
# unacked_data is [datetime sent_time, string data, bool retransmitted]
# acked_time is a datetime
def calc_rto(unacked_data, acked_time):
    global RTT, RTO
    if unacked_data[2]: # if the sample is a retransmitted packet
        return
    else:
        diff = acked_time - unacked_data[0]
        sample =diff.seconds + diff.microseconds/float(1000000)
        RTT = alpha * RTT + (1 - alpha) * sample
        RTO = 2 * RTT


# send syn packet and setup connection (handshake)
def setup_connection():
    global SEQUENCE, unacked_packets, RTO

    # Send first syn packet
    msg = json.dumps({"seq_num": SEQUENCE, "flags": 1, "data": ""})
    log("[send syn] " + str(SEQUENCE) + " (" + str(1) + ")")
    unacked_packets[SEQUENCE] = [datetime.datetime.now(), "", False]
    SEQUENCE+=1
    sock.sendto(msg, dest)


# retransmit the given packet
def retransmit_after_timeout(unacked):
    global cwnd, eff_wnd, ssthresh, unacked_packets, SEQUENCE

    ssthresh = cwnd / 2
    cwnd = 1

    log("[send data] " + str(unacked[0]) + " (" + str(len(unacked[1][1])) + ")")
    msg = json.dumps({"seq_num": unacked[0], "data": unacked[1][1], "flags": 0})

    unacked_packets[unacked[0]][2] = True # set retransmitted to True

    if sock.sendto(msg, dest) < len(msg):
        log("[error] unable to fully send packet")



# check timeouts for unacked packets
# if timeout, retransmit the timed out packet
def check_timeout():
    global RTO, unacked_packets, SEQUENCE
    items = unacked_packets.items()
    for ii in range(len(items)):
        unacked = items[ii]
        diff = datetime.datetime.now() - unacked[1][0]
        if diff.seconds + diff.microseconds / 1000000 >= RTO:
            # timed out waiting for ACK with ack_num given
            log("[timeout] ACK " + str(unacked[0] + len(unacked[1][1])))
            retransmit_after_timeout(unacked)


def send_next_packet():
    global SEQUENCE, unacked_packets, eff_wnd

    check_timeout()

    while (min(cwnd, adv_wnd) - eff_wnd > 0):

        retransmit = unacked_packets.get(SEQUENCE, None)
        # if SEQUENCE already in unacked_packets, it's a retransmission
        if retransmit:
            # reset sent time to now; flag as retransmitted
            data = retransmit[1]
            unacked_packets[SEQUENCE][0] = datetime.datetime.now()
            unacked_packets[SEQUENCE][2] = True
        else: # new data
            data = sys.stdin.read(MSS)

        if (len(data) > 0):
            msg = json.dumps({"seq_num": SEQUENCE, "data": data, "flags": 0})
            log("[send data] " + str(SEQUENCE) + " (" + str(len(data)) + ")")
            if not retransmit:
                # add packet to unacked_packets
                unacked_packets[SEQUENCE] = [datetime.datetime.now(), data, False]

            SEQUENCE += len(data)
            eff_wnd+=1

            if sock.sendto(msg, dest) < len(msg):
                log("[error] unable to fully send packet")


        else:
            return False

    return True


def teardown_connection(attempts):
    global unacked_packets, eff_wnd, SEQUENCE, RTO

    if attempts < 3:
        log("[send fin] " + str(SEQUENCE))
        sock.sendto(json.dumps({"data": "", "seq_num": SEQUENCE, "flags": 2}), dest)
        ready = select.select([sock], [], [], RTO)
        if ready[0]:
            result = ready[0][0].recvfrom(MTU)
            (data, addr) = result
            try:
                decoded = json.loads(data)
                if decoded['flags'] == 6 and decoded['ack'] == SEQUENCE+1:
                    log("[recv fin/ack] " + str(decoded['ack']))
                    log("[completed]")
                    sys.exit(0)
                else:
                    log("[fin/ack error] " + str(decoded['ack']))
                    sys.exit(0)
            except():
                log("[recv corrupt fin packet]")
                teardown_connection(attempts+1)
        else:
            teardown_connection(attempts+1)
    else:
        log("[completed]")
        sys.exit(0)




############################### MAIN #########################################

setup_connection()
while True:

    ready = select.select([sock], [], [], RTO)
    # if data is available to be read from the socket
    if ready[0]:
        result = ready[0][0].recvfrom(MTU)
        (data, addr) = result

        # record time a potential ACK was received
        ack_time = datetime.datetime.now()

        try:
            decoded = json.loads(data)

            # SYN packet
            if decoded['flags'] == 5 and decoded['ack'] == SEQUENCE:
                syn = SEQUENCE - 1 # sequence num of syn packet
                synced = True
                log("[recv syn/ack] " + str(SEQUENCE) + " : Connection establishing")

                # calculate initial RTT and new RTO
                calc_rto(unacked_packets[syn], ack_time)
                # remove the packet from unacked_packets
                del unacked_packets[syn]
                send_next_packet()


            # ACK packet
            else:
                # Retrieve corresponding data in unacked_packets for the received ACK

                ack_num = decoded['ack']
                # the difference between the ack num and its corresponding seq num is either MSS or,
                # in the case that it is the last data packet sent and its length < MSS,
                # difference is ack num - len(data)
                seq_num = ack_num - MSS

                # get the [sent_time, data, retransmitted] for the packet the ack_num is for
                unacked_data = unacked_packets.get(seq_num, None)

                # check if last packet unacked has data length < MSS, and if that's matching seq num
                all_unacked = unacked_packets.items()
                length = len(all_unacked)
                if not unacked_data and length > 0:
                    if all_unacked[length - 1][0] + len(all_unacked[length - 1][1][1]) == ack_num:
                        seq_num = all_unacked[length - 1][0]
                        unacked_data = unacked_packets[seq_num]


                # new ACK
                if unacked_data is not None:
                    log("[recv ack] " + str(ack_num))
		    
                    # update cwnd and RTO
                    calc_rto(unacked_data, ack_time)
                    # remove acked packet from unacked_packets
                    del unacked_packets[seq_num]

                    if cwnd < ssthresh: # slow start
                        cwnd += 1
                    else: # congestion avoidance
                        cwnd += 1 / cwnd

                    # sliding window slides forward
                    eff_wnd-=1

                    # Try to send next packet; break if no more data and all packets have been acked
                    if (not send_next_packet()) and len(unacked_packets.items()) == 0:
                        break


                # duplicate ACK (ignored)
                else:
                    check_timeout()

        except (ValueError, KeyError, TypeError):
            log("[recv corrupt packet]")
            # window slides forward
            eff_wnd-=1

    else:
        # timed out waiting for a SYN/ACK packet
        if not synced:
            SEQUENCE-=1
            setup_connection()

        # timed out waiting for data ACK packet
        else:
            items = unacked_packets.items()
            if len(items) > 0:
                retransmit_after_timeout(items[0])

teardown_connection(0)
